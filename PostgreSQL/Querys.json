[{"CREATE TABLE \"nombre_dela_tabla\"(statements); ": " crea una tabla, dentro de statements se introducen los valores a crear en la tabla.", "INSERT INTO \"nombre_dela_tabla\"(proporcion) VALUES (\"valor_1\",\"valor_2\"); ": " introduce en la tabla con la proporcion indicada  los valores.", "DELETE FROM \"nombre_dela_tabla\" WHERE (\"fila\"=\"correspondencia\"); ": " borra de la tabla los datos relacionados al valor introducido en \"correspondencia\" segun \"fila\", si no se introduce clapsula \"Where\" se chapea todo.", "UPDATE \"nombre_dela_tabla\" SET (\"fila\"=\"nuevo_valor\") WHERE (\"fila\"=\"correspondencia\"); ": " actualiza a \"nuevo valor\" la coorespondencia escrita en fila.", "SELECT*FROM \"nombre_dela_tabla\" WHERE (\"fila\"=\"correspondencia\"); ": " devuelve los datos acordes a la fila que contiene \"fila\"=\"correspondencia\". si se omite clausula WHERE devuelve todos los datos de la tabla; ORDER BY \"fila\" or ORDER BY \"fila\" DESC devuelve ordenado; AS: permite cambiar el nombre de las columnas en las que se muestran los resultados; LIMIT: permite limitar el numero de respuestas a tanto;Group By: es como un distintic; LIKE: para experesiones regulares, %: cualquier numero de caracteres, _ : un caracter;OFFSET: salta el numero especificado dentro de arg; HAVING: se usa como where una vez que esta ha sido escrito y se necesita otra informacion de la anterior recolectada, tambien es util porque puede ir despues de un group by, danadonos el chance de agrupar y luego filtrar.", "DROP TABLE \"nombre_dela_tabla\" ": " dropea la tabla.", "ALTER TABLE \"nombre_dela_tabla\" ADD \"nombre_dela_columna\" \"Tipo_de_dato\" ": " modifica la tabla agregando la columna o con drop la elimina.", "(JOIN)SELECT \"las_columnas_que_deseas_ver\" FROM \"tabla#1\" JOIN \"tabla#2\" ON \"clave_foreign#1\" = \"clave_foreign#2\" ": " pape, mete en una solo tabla todo lo que quieres ver mediante la conexion de la clave foreign.", "ALTER TABLE \"\" ALTER COLUMN \"\" TYPE \"\"": "para cambiar el tipo de datos de columnas.", "RETURNING *": "al final de la query retorna el valor que fue insertado o actualizado.", "ON CONFLICT \"statment\" DO \"esto\"": "es como el try and except in python, if its in conflict DO NOT BLOW UP, instead do this. ", "CREATE OR REPLACE FUNCTION \"nombre_dela_funcion_trigger()\" RETURNS TRIGGER AS $$ BEGIN NEW.\"nombre_dela_columna\" = NOW(); RETURNS NEW; END; $$ LANGUAGE plpgsql;": "crea la funcion trigger chama, para despues poder crear el trigger.", "CREATE TRIGGER \"nombre_del_trigger\" BEFORE INSERT(others too) FOR EACH ROW EXCECUTE PROCEDURE \"nombre_dela_funcion_trigger\"": "para implementar el trigger anteriormente creado. \n \nSELECT pg_relation_size('nombre_dela_tabla') - muestra el peso del contenido de la tabla.", "SELECT pg_indexes_size('nombre_dela_tabla')": "muestra el peso de los indices.", "CREATE INDEX 'nombre_del_index' ON 'nombre_dela_tabla'('nombre_dela_columna')": "crea un indice(default es b_tree).", "BEGIN and ROLLBACK": "comienza  una transacci\u00c3\u00b3n, rollback vuelve al inicio de una transacci\u00c3\u00b3n."}]