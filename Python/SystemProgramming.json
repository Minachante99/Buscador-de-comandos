[{"sys.exit()": "cierra la aplicacion.", "sys.version": "muestra la version actual de python.", "os.path.isfile(arg)": "retorna un booleano si el archivo especificado con su direccion existe.", "os.system(arg)": "invoca comandos en la consola como subprocesos.", "os.getcwd()": "retorna la direccion de la carpeta actual(cwd=current working directory).", "os.path.realpath(__file__)": "retorna la direccion con el nombre del archivo actual.", "sys.platform": "muestra en que plataforma se est\u00e1 corriendo(linux,win,etc).", "sys.path": "devuelve una lista con todo los directorios de PYTHONPATH, que puede ser cambiada para que python sepa de donde importar pero s\u00f3lo dura mientras este programa se corre, despu\u00e9s se reinicia.", "sys.modules": "muestra todos los m\u00f3dulos utilizados en el programa.", "sys.exc_info()": "devuelve una tupla con informaci\u00f3n de la \u00faltima excepci\u00f3n(exception_information).", "os.getpid()": "devuelve el id \u00fanico del programa que se est\u00e1 corriendo(programa id).", "os.chdir(arg)": "para cambiar directorio hasta y trabajar en el hasta que finalice el programa(change directory)", "os.listdir()": "lista todo en la carpeta, se le puede pasar direcci\u00f3n como argumento, pincha igual que glob.glob()(pero mas rapido).", "os.sep": "devuelve el separador de paths del sistema operativo.", "os.path.isdir(arg)": "devuelve un booleano si es un directorio o no.", "os.path.exists(arg)": "devuelve un booleano si existe o no.th", "os.path.getsize(arg)": "devuelve el peso de un archivo.", "os.path.split(arg)": "divide el path en dos (head,tail), donde tail es todo despu\u00e9s del \u00faltimo separetor(/,\\) y head es lo que hay antes.", "os.path.abspath(arg)": "devuelve el path completo de arg.", "os.popen(arg)": "para invocar comandos en la consola como subprocesos y, a diferencia de os.system, permite guardar los output.", "os.mkdir(arg)": "crea una carpeta de nombre arg.", "os.rmdir(arg)": "elimina una carpeta de nombre arg.", "sys.argv": "devuelve una lista con los argumentos que se pasaron a la hora e ejecutar el script.v", "sys.stdin(": "toma los valores del teclado, es la forma de entrada default(input)(Standard input)(se usa con read()).Para pasarle un archivo como input se utiliza '< archivo' como argumento al levantar el archivo.", "sys.stdout()": "muestra los valores a pantalla(print)(Standard output)(se usa con write).Para que el output vaya a un archivo se utiliza '> archivo' como argumento al levantar el archivo en la shell.", "os.write(fileno,b'arg')": "otra forma de redireccionar stdout, si fileno>=3 es para archivos cargados, deben ir encodeados.", "os.rename(file's name, new file's name)": "le cambia el nombre a un archivo.", "os.remove(arg)": "remueve un archivo.", "os.walk(dir)": "devuelve una tupla con tres elementos: dir_actual,subdirectorios,archivos; es un generador que transversa carpetas llamando listdir en cada una.", "os.fork()": "divide programas inicializando como programas apartes parte del c\u00f3digo.", "os.execv(arg) and os.execl(arg)arg": "toman como primer arg un programa a inicializar, y dem\u00e1s arg como argumentos pasados a el programa(sus.argv). Para m\u00e1s detalles buscar sus otras 6 variantes(mamatela). ", "_thread.start_new_thread(func,(args))": "levanta un nuevo hilo dentro del programa en func se le pasa la funci\u00f3n y los args mediante una tupla.", "_thread.allocate_lock()": "se guarda en una variable para guardarlo como un objeto,se utiliza para sincronizar threads bloqueando y liberando el acceso, luego mediante .acquire() and .release() respectivamente.\n", "threading.Lock()": "sinonimo de _thread.allocate_lock()", "Thread.join()": "un metodo de la clase Thread, se usa para hacer esperar al main program a que los children threads terminen antes de terminar.", "queue.Queue()": "se usa para inicializar el dipocket, se guarda en una variable.", "queue.Queue.put(arg)": "mete args en el dipocket.", "queue.Queue.get(block=False)": "se utiliza para leer cosas del dipocket.",  "_thread.exit()": "se usa para cerrar threads(en childs).", "os._exit()": "para cerrar el programa, es inmune a try\\except or try\\finally(se los pasa por).", "_thread.get_ident()": "devuelve el id de ese thread.", "threading.Thread('target='function,'args='tupla).start()": "levanta un thread, en function especificamos la funcion y en tupla los argumentos que se le van a pasar en forma de tupla.", "os.pipe()": "crea un objeto que permite recibir y enviar informaci\u00f3n entre dos funciones.", "multiprocessing.Process('target='func,'args='argumentos)": "sirve para levantar un proceso,trabaja como la clase Process es Thread del threading, asi que cada procesos tiene un start, join, y una clase Lock.", "multiprocessing.Pipe()": "crea una objeto(tupla) que permite enviar mediante Pipe.send() and recivir mediante Pipe.recv()(que espera hasta que haya algo para recivir) que puede ser escuchado mediante otros pipes, siendo las pipes anonimas una forma de comunicacion entre programas."}]