[
  {
    "df.drop()": "devuelve la instancia pero sin lo dropeado. Recordar que la funcion busca por indice(agregar .index al final de la operacion), si se desea dropear una columna se debe especificar el axis=1 or columns=[columnas].",
    "df.rename()": "para cambiar nombre de objetos, columns={old:new} para cambiar columnas or axis=1.",
    "inst.head(n) and inst.tail(n)": "muestra los primeros y ultimos(respectivamente) n elementos del df; n=5 default.",
    "df.set_index(col)": "cambia el indice a lo indicado(otra columna).",
    "df.dropna(arg)": "eliminas las fila que tengan al menos un valor nulo, en la opciones de arg se puede cambiar si se desea por columnas con axis=1; thresh= : especifica a dropear filas o columnas con esa cantidad de valores no nulos.",
    "df.fillna(arg)": "rellena los valores nulos con arg, para usar en multiples columnas usar un dic de forma {column: valor para rellenar}; bfill and ffill ya son funciones apartes.",
    "s.unique()": "devuelve los valores unicos; inst.nunique los cuenta.",
    "df.value_counts()": "cuenta la cantidad de valores distintos(agrupandolos por separado).",
    "df.replace({old:new})": "cambia old for new.",
    "inst.to_csv(path)": "permite guardar como csv.",
    "df.groupby(arg)": "agrupa por unique y se le puede pasar otro argumento por el que se quiera diferenciar los datos, devuelve un objeto Groupby;unstack(fill_value=) para cuando se quiere observar lo de una misma columna en columnas creando una tabla.",
    "inst.sample(#)": "muestra 10 records aleatorios. ",
    "df.merge(dataframe,on=col)": "para unir dataframes por relacionados por alguna columna;how= define de que forma el join(default='inner'); left_on= and right_on= especifica las columnas de los dos dataframes en las cual se deben corresponder, devuelve un dataframe con ambos mezclados;suffixies=(arg1,arg2) por si hay nombres en conflicto que le ponga sufijos para diferenciarlos.",
    "df.sort_values()": "sortea los valores; ascending= False : organiza de forma descendiente;by=[columns] especifica las columnas.",
    "inst.duplicated()": "devuelve 0 or 1 segun valores repetidos, subset=[columna] para specificar; keep='first' or 'last' or False(todos) : para que guarde el dato de cual es duplicado.",
    "inst.drop_duplicates()": "dropea repetidos,acepta los mismos parametros que duplicated(), subset y keep.",
    "inst.count()": "cuenta todos los datos. ",
    "s.median()": "devuelve la mediana.",
    "s.quantile(%)": "devuelve el porciento especificado.",
    "s.mode()": "devuelve el valor mas usado,pero debe buscarse el indice [0] ya que devuelve un df.",
    "inst.plot()": "para plotear solo con pandas; kind= : para especificar que tipo de chart se quiere, si se deja vacio toma line por defecto; label= : nombre del label(pie); xlabel and ylabel: nombre de los labels; title= : nombre del chart; color= : colores, figsize= tuple : especifica tama\u00f1o; autopct='%1.1f%%' : autorellena con porcientos(pie). Podemos especificar distintos charts como 'bar','barh','scatter','pie','hist','hexbin' entre otros; se puede especificar ax(como sns) para plotearlo en algun subplot.",
    "inst.str.func": "para manipular strings, se puede usar la mayoria de los methods str(for example : inst.str.capitalize()); str.contains(substring,case=False): prueba so contiene el substring.",
    "inst.isin(arg)": "devuelve pd.NA en caso de que no se encuentre dentro de arg(evalua si algo esta dentro de argumento)",
    "inst.isna()": "devuelve una lista de bools si los elementos son pd.NA o no. Usar con sum() para saber cantidad.",
    "df.reset_index()": "resetea el index a RangeIndex again haciendo el antiguo index una columna; drop=True : drope el indice viejo; name= para ponerle nombre a las nuevas columnas que surjan en caso de ser un indice jerarquico.",
    "df.corr()": "crea una matriz de correlacion(tiza).",
    "inst.astype(type)": "devuelve con otro type.",
    "inst.round(decimals=#)": "redondea odo lo que hay dentro de la instancia(numeric).",
    "s.std()": "halla el Standard deviation que es la ra\u00edz cuadrada de la varianza.",
    "inst.var()": "calcula la varianza, que es el promedio de los cuadrados de las desviaciones.",
    "df.apply(func)": "le pasa una funcion a cada elemento, ya sea columna o fila(axis=1).",
    "inst.idxmax()": "devuelve el indice del mayor; df.idxmin hace lo mismo pero con minimo.",
    "inst.to_frame()": "convierte una serie a df.",
    "df.select_dtypes(include=)": "selecciona las columnas con tipo especificado en include; 'number' para incluir o excluir odo lo que sea numero(int,float) y 'object' para el resto.",
    "df.agg({col: metodo} or function or [functions])": "para pasarle una o varias func a una o varias columnas;otra forma de los argumentos puede ser nombre(func,col) para crear una columna nueva pasandole el str de esa func a la columna.",
    "df.transform(func)": "le pasa una funcion pero lo lleva al shape del dataset en el que se quiera utilizar el resultado.",
    "df.plot(kind='hexbin')": "crea un hexagonal binning que se usa como un scatterplot para comparar dos variables num\u00e9ricas pero para cuando hay demasiados datos que no se hace legible un scatter, poniendo como puntos de presi\u00f3n representando los bins como hex\u00e1gonos describiendo la cantidad de puntos que contiene.",
    "df.to_json()": "salva el dataframe a json.",
    "inst.sum()": "para sumar, axis=1 para hacerlo horizontalmente.",
    "s.pct_change()": "devuelve el cambio en porciento sucesivamente entre uno y el anterior."
  }
]